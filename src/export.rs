//! Export formatting for JSON, CSV, and Markdown

use crate::error::PortrError;
use crate::port::PortInfo;
use serde::Serialize;

/// Export format enum
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ExportFormat {
    Json,
    Csv,
    Markdown,
}

/// Export data to JSON format
pub fn to_json<T: Serialize>(data: &T) -> Result<String, PortrError> {
    serde_json::to_string_pretty(data).map_err(|e| PortrError::ExportError(e.to_string()))
}

/// Export ports to CSV format
pub fn to_csv(ports: &[PortInfo]) -> String {
    let mut csv = String::new();

    // Header
    csv.push_str(
        "port,protocol,pid,process,state,local_address,memory_mb,cpu_percent,uptime_secs\n",
    );

    // Rows
    for p in ports {
        csv.push_str(&format!(
            "{},{},{},{},{},{},{:.1},{:.1},{}\n",
            p.port,
            p.protocol,
            p.pid,
            escape_csv(&p.process_name),
            p.state,
            p.local_address,
            p.memory_mb,
            p.cpu_percent,
            p.uptime_secs
        ));
    }

    csv
}

/// Export single port to CSV format
pub fn port_to_csv(port: &PortInfo) -> String {
    to_csv(std::slice::from_ref(port))
}

/// Export ports to Markdown table format
pub fn to_markdown(ports: &[PortInfo]) -> String {
    let mut md = String::new();

    // Title
    md.push_str("# Port Report\n\n");
    md.push_str(&format!("**Total ports:** {}\n\n", ports.len()));

    // Table header
    md.push_str("| Port | Protocol | PID | Process | State | Memory | CPU | Uptime |\n");
    md.push_str("|------|----------|-----|---------|-------|--------|-----|--------|\n");

    // Rows
    for p in ports {
        md.push_str(&format!(
            "| {} | {} | {} | {} | {} | {:.1} MB | {:.1}% | {} |\n",
            p.port,
            p.protocol,
            p.pid,
            escape_md(&p.process_name),
            p.state,
            p.memory_mb,
            p.cpu_percent,
            p.uptime_display()
        ));
    }

    md.push_str("\n---\n");
    md.push_str("*Generated by [portr](https://github.com/Brutus1066/portr) - ðŸ¸ LazyFrog | kindware.dev*\n");

    md
}

/// Export single port to Markdown format
pub fn port_to_markdown(port: &PortInfo) -> String {
    let mut md = String::new();

    md.push_str(&format!("# Port {} Report\n\n", port.port));

    md.push_str("## Details\n\n");
    md.push_str(&format!("- **Port:** {}\n", port.port));
    md.push_str(&format!("- **Protocol:** {}\n", port.protocol));
    md.push_str(&format!("- **PID:** {}\n", port.pid));
    md.push_str(&format!("- **Process:** {}\n", port.process_name));
    md.push_str(&format!("- **State:** {}\n", port.state));
    md.push_str(&format!("- **Local Address:** {}\n", port.local_address));

    if let Some(ref remote) = port.remote_address {
        md.push_str(&format!("- **Remote Address:** {}\n", remote));
    }

    md.push_str(&format!("- **Memory:** {:.1} MB\n", port.memory_mb));
    md.push_str(&format!("- **CPU:** {:.1}%\n", port.cpu_percent));
    md.push_str(&format!("- **Uptime:** {}\n", port.uptime_display()));

    if let Some(ref path) = port.process_path {
        md.push_str(&format!("- **Path:** `{}`\n", path));
    }

    if let Some(ref user) = port.user {
        md.push_str(&format!("- **User:** {}\n", user));
    }

    md.push_str("\n---\n");
    md.push_str("*Generated by [portr](https://github.com/Brutus1066/portr) - ðŸ¸ LazyFrog | kindware.dev*\n");

    md
}

/// Escape special characters for CSV
fn escape_csv(s: &str) -> String {
    if s.contains(',') || s.contains('"') || s.contains('\n') {
        format!("\"{}\"", s.replace('"', "\"\""))
    } else {
        s.to_string()
    }
}

/// Escape special characters for Markdown
fn escape_md(s: &str) -> String {
    s.replace('|', "\\|")
        .replace('*', "\\*")
        .replace('_', "\\_")
}

#[cfg(test)]
mod tests {
    use super::*;

    fn sample_port() -> PortInfo {
        PortInfo {
            port: 3000,
            protocol: "TCP".to_string(),
            pid: 1234,
            process_name: "node".to_string(),
            process_path: Some("/usr/bin/node".to_string()),
            local_address: "0.0.0.0:3000".to_string(),
            remote_address: None,
            state: "LISTENING".to_string(),
            user: Some("user".to_string()),
            memory_mb: 156.3,
            cpu_percent: 2.4,
            uptime_secs: 12345,
            parent_pid: None,
            parent_name: None,
        }
    }

    #[test]
    fn test_csv_export() {
        let ports = vec![sample_port()];
        let csv = to_csv(&ports);
        assert!(csv.contains("port,protocol,pid"));
        assert!(csv.contains("3000,TCP,1234"));
    }

    #[test]
    fn test_markdown_export() {
        let ports = vec![sample_port()];
        let md = to_markdown(&ports);
        assert!(md.contains("# Port Report"));
        assert!(md.contains("| 3000 |"));
        assert!(md.contains("portr"));
    }

    #[test]
    fn test_csv_escape() {
        assert_eq!(escape_csv("hello"), "hello");
        assert_eq!(escape_csv("hello,world"), "\"hello,world\"");
        assert_eq!(escape_csv("say \"hi\""), "\"say \"\"hi\"\"\"");
    }

    #[test]
    fn test_md_escape() {
        assert_eq!(escape_md("hello|world"), "hello\\|world");
    }
}
